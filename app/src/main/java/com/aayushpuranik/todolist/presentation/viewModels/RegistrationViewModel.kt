package com.aayushpuranik.todolist.presentation.viewModelsimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport com.aayushpuranik.todolist.domain.model.Personimport com.aayushpuranik.todolist.domain.useCase.RegistrationUserCaseimport com.aayushpuranik.todolist.domain.useCase.ValidateConfirmPasswordimport com.aayushpuranik.todolist.domain.useCase.ValidateEmailimport com.aayushpuranik.todolist.domain.useCase.ValidateNameimport com.aayushpuranik.todolist.domain.useCase.ValidatePasswordimport com.aayushpuranik.todolist.presentation.UIStateimport dagger.hilt.android.lifecycle.HiltViewModelimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.delayimport kotlinx.coroutines.launchimport kotlinx.coroutines.withContextimport javax.inject.Inject@HiltViewModelclass RegistrationViewModel @Inject constructor() : ViewModel() {    var dataLiveData = MutableLiveData<UIState<Person?>>()    val nameErrorLiveData = MutableLiveData<String>()    val emailErrorLiveData = MutableLiveData<String>()    val passwordErrorLiveData = MutableLiveData<String>()    val confirmPasswordErrorLiveData = MutableLiveData<String>()    @Inject    lateinit var nameValidator: ValidateName    @Inject    lateinit var userCase: RegistrationUserCase    fun addContact(person: Person, confirmPassword: String?) {        CoroutineScope(Dispatchers.Main).launch {            dataLiveData.value = UIState.Loading            delay(2000)            if (isValid(person, confirmPassword)) {                val result = userCase.execute(person)                when (result) {                    is UIState.Error -> dataLiveData.value = UIState.Error(result.exception.toString())                    is UIState.Loading -> dataLiveData.value = UIState.Loading                    is UIState.Success -> dataLiveData.value = UIState.Success(result.data)                }            } else {                dataLiveData.value = UIState.Error("Something went wrong. Please check the data again")            }        }    }    fun isValid(person: Person, confirmPassword: String?): Boolean {        val nameValidate = nameValidator.execute(person.Name)        val emailValidate = ValidateEmail().execute(person.email)        val passwordValidate = ValidatePassword().execute(person.password)        val confirmPassword = ValidateConfirmPassword().execute(person.password,confirmPassword)        if(nameValidate.Success && emailValidate.Success && passwordValidate.Success && confirmPassword.Success) {            return true        } else {            if (!nameValidate.Success) {                nameErrorLiveData.value = nameValidate.errorMessage            }            if (!emailValidate.Success) {                emailErrorLiveData.value = emailValidate.errorMessage            }            if (!passwordValidate.Success) {                passwordErrorLiveData.value = passwordValidate.errorMessage            }            if (!confirmPassword.Success) {                confirmPasswordErrorLiveData.value = confirmPassword.errorMessage            }            return false        }    }}